import os
import sys
import re
import argparse
import ast
from scipy.stats import iqr     # statistics doesnt include quantiles until python 3.8
from statistics import mean, median, variance


def dir_path(string):
    if os.path.isdir(string):
        return string
    else:
        raise NotADirectoryError(string)

parser = argparse.ArgumentParser(description='Sort the results from decoding by the different \
        parameters to make analysis a little easier')
parser.add_argument('resultsDir', type=dir_path,
        help='The result directory generated by decode_music.sh: results-mix-snrXX-lvXX-startXX.')
parser.add_argument('type', type=str,
        help='Either "char" or "word". Specifies the types of decoding results to sort')
parser.add_argument('testSet', type=str,
        help='Either "dev" or "eval", selecting WSJ "test_dev93" or "test_eval92" respectively to sort')
parser.add_argument('--output-dir', type=str, metavar='path',
        help='Place to put the sorted results. If not specified, the results will be placed in the current \
                directory.')


def get_short_noise_source_name(path):
    source_file = os.path.splitext(os.path.basename(path))[0]
    source_dir = os.path.basename(os.path.dirname(path))
    return '{}__{}'.format(source_dir, source_file)


def parse_noise_utt_map(filepath, results={}, basepath=None):
    sorted_results = {}
    with open(filepath, 'r') as f:
        file_list_line = next(f).strip()
        file_list = ast.literal_eval(file_list_line)
        if basepath is not None:
            file_list = [file_.replace(basepath, '') for file_ in file_list]
        for line in f:
            uttId, noise_idx = line.split()
            noise_idx = int(noise_idx)
            noise_source = file_list[noise_idx]
            short_noise_source = get_short_noise_source_name(noise_source)
            results[uttId]['noise_source'] = noise_source
            results[uttId]['shortened_noise_source'] = short_noise_source
            if short_noise_source not in sorted_results:
                sorted_results[short_noise_source] = {}
            sorted_results[short_noise_source][uttId] = results[uttId]
    return results, sorted_results


def parse_spk2gender(filepath, results={}):
    sorted_results = {}
    spk2gender = {}
    with open(filepath, 'r') as f:
        for line in f:
            speaker, gender = line.strip().split()
            spk2gender[speaker] = gender
    for uttId in results:
        gender = spk2gender[uttId[:3]]
        results[uttId]['gender'] = gender
        if gender not in sorted_results:
            sorted_results[gender] = {}
        sorted_results[gender][uttId] = results[uttId]
    return results, sorted_results


def parse_result_txt(filepath, results={}):
    sorted_results = {}
    with open(filepath, 'r') as f:
        while True:
            try:
                line = next(f)
                if line[:3] == 'id:':
                    match = re.search('^id: \(([\d\w]+)-([\d\w]+)\)', line)
                    speaker = match.group(1)
                    uttId = match.group(2)
                    results[uttId] = {'speaker': speaker}

                    Scores_line = next(f)
                    match = re.search('^Scores: \(#C #S #D #I\) (\d+) (\d+) (\d+) (\d+)', Scores_line)
                    results[uttId]['scores'] = {'correct': match.group(1),
                                               'substitution': match.group(2),
                                               'deletion': match.group(3),
                                               'insertion': match.group(4)}

                    REF_line = next(f)
                    # ref = re.search('^REF:  (.+)', REF_line).group(1).strip()
                    results[uttId]['reference'] = REF_line[6:].strip()

                    HYP_line = next(f)
                    # hyp = re.search('^HYP:  (.+)', HYP_line).group(1).strip()
                    results[uttId]['hypothesis'] = HYP_line[6:].strip()

                    Eval_line = next(f)
                    # eval = re.search('^Eval: (.+)', Eval_line).group(1).strip()
                    results[uttId]['evaluation'] = Eval_line[6:].strip()

                    results[uttId]['original_output'] = '{}{}{}{}{}\n'.format(line, Scores_line,
                            REF_line, HYP_line, Eval_line)

                    if speaker not in sorted_results:
                        sorted_results[speaker] = {}
                    sorted_results[speaker][uttId] = results[uttId]

            except StopIteration:
                break

    return results, sorted_results


def summarize_results(results):
    _scores = {'correct': [],
               'substitution': [],
               'deletion': [],
               'insertion': []}
    scores = {category: _scores.copy() for category in results.keys()}
    for category in results.keys():
        for utterance in results[category]:
            this_scores = results[category][utterance]['scores']
            for typ in this_scores.keys():
                scores[category][typ].append(int(this_scores[typ]))
    return scores


def str_scores(scores):
    res = ''
    n = len(scores['correct'])  # All fields SHOULD be the same length
    res += 'Number of utterances: {}\n'.format(n)
    res += 'Sum | Correct: {}\t\tSubstitution: {}\t\tDeletion: {}\t\tInsertion: {}\n'.format(
            sum(scores['correct']), sum(scores['substitution']), sum(scores['deletion']), sum(scores['insertion']))
    res += 'Avg | Correct: {:.3f}\t\tSubstitution: {:.3f}\t\tDeletion: {:.3f}\t\tInsertion: {:.3f}\n'.format(
            mean(scores['correct']), mean(scores['substitution']), mean(scores['deletion']), mean(scores['insertion']))
    res += 'Med | Correct: {:.3f}\t\tSubstitution: {:.3f}\t\tDeletion: {:.3f}\t\tInsertion: {:.3f}\n'.format(
            median(scores['correct']), median(scores['substitution']), median(scores['deletion']), median(scores['insertion']))
    res += 'Var | Correct: {:.3f}\t\tSubstitution: {:.3f}\t\tDeletion: {:.3f}\t\tInsertion: {:.3f}\n'.format(
            variance(scores['correct']), variance(scores['substitution']), variance(scores['deletion']), variance(scores['insertion']))
    res += 'IQR | Correct: {:.3f}\t\tSubstitution: {:.3f}\t\tDeletion: {:.3f}\t\tInsertion: {:.3f}\n'.format(
            iqr(scores['correct']), iqr(scores['substitution']), iqr(scores['deletion']), iqr(scores['insertion']))
    return res


def write_results(results, output_dir):
    scores = summarize_results(results)
    for category in results.keys():
        output_path = os.path.join(output_dir, category)
        if not os.path.isdir(output_path):
            os.mkdir(output_path)
        output_file = os.path.join(output_path, 'results.txt')
        with open(output_file, 'w') as f:
            f.write(str_scores(scores[category]))
            f.write('\n\n')
            for uttId in results[category]:
                f.write(results[category][uttId]['original_output'])
                f.write('\n')


if __name__ == '__main__':

    args = parser.parse_args()

    test_sets = ['test_dev93', 'test_eval92']
    if args.testSet == 'dev':
        test_set = test_sets[0]
    elif args.testSet == 'eval':
        test_set = test_sets[1]

    decode_result_dir = lambda s: 'decode_{}_decode_lm_word65000'.format(s)
    if args.type == 'char':
        result_txt_path = os.path.join(args.resultsDir, decode_result_dir(test_set), 'result.txt')
    elif args.type == 'word':
        result_txt_path = os.path.join(args.resultsDir, decode_result_dir(test_set), 'result.wrd.txt')
    results, sorted_results_by_speaker = parse_result_txt(result_txt_path)

    noise_utt_map_file = lambda s: '{}_noise_utt_map'.format(s)
    noise_utt_map_path = os.path.join(args.resultsDir, noise_utt_map_file(test_set))
    results, sorted_results_by_noise = parse_noise_utt_map(noise_utt_map_path, results)
    
    spk2gender_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'espnet', 'egs',
            'wsj', 'asr1', 'data', test_set, 'spk2gender')
    results, sorted_results_by_gender  = parse_spk2gender(spk2gender_path, results)

    if args.output_dir is None:
        output_dir = '.'
    else:
        output_dir = args.output_dir
        if not os.path.exists(output_dir):
            os.mkdir(output_dir)
    
    speaker_dir = os.path.join(output_dir, 'by_speaker')
    if not os.path.isdir(speaker_dir):
        os.mkdir(speaker_dir)
    write_results(sorted_results_by_speaker, speaker_dir)

    noise_dir = os.path.join(output_dir, 'by_noise')
    if not os.path.isdir(noise_dir):
        os.mkdir(noise_dir)
    write_results(sorted_results_by_noise, noise_dir)

    gender_dir = os.path.join(output_dir, 'by_gender')
    if not os.path.isdir(gender_dir):
        os.mkdir(gender_dir)
    write_results(sorted_results_by_gender, gender_dir)

